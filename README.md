## 🛠 技術スタック

### アーキテクチャ
- **MVVM** (Model-View-ViewModel)
- **Repository Pattern**
- **Clean Architecture** (Data/Domain/Presentation層の分離)

### UI層
- **Jetpack Compose** - 宣言的UI
- **Material Design 3** - モダンなデザイン
- **Navigation Compose** - 画面遷移
- **Coil** - 画像読み込み・キャッシング

### ネットワーク層
- **Retrofit** - HTTPクライアント
- **OkHttp** - ネットワークインターセプター
- **Gson** - JSONシリアライゼーション
- **指数バックオフリトライ** - エラー時の自動再試行

### データ層
- **Room Database** - ローカルデータベース
- **Flow** - リアクティブストリーム
- **Type Converters** - カスタム型変換
- **キャッシュファースト戦略**

### 依存性注入
- **Hilt** - Dependency Injection

### 非同期処理
- **Coroutines** - 非同期処理
- **Flow** - データストリーム
- **StateFlow** - UI State管理

## 🎯 技術選定の理由

### なぜRetrofitを選んだのか？

**Retrofit** を選択した理由：

1. **業界標準**
    - Android開発で最も広く使われているHTTPクライアント
    - 求人市場でも必須スキルとして要求されることが多い
    - 豊富なドキュメントとコミュニティサポート

2. **使いやすさ**
    - アノテーションベースのシンプルなAPI定義
    - ボイラープレートコードが少ない
    - Coroutines/Flowとの統合が簡単

3. **拡張性**
    - 様々なコンバーター対応（Gson, Moshi, Kotlinx Serialization）
    - カスタムインターセプターによる柔軟な処理
    - リトライロジック、認証、ログなどを簡単に実装可能

4. **安定性**
    - 長年の実績と成熟したライブラリ
    - バグが少なく、パフォーマンスが優れている
    - Square社による継続的なメンテナンス

**他の選択肢との比較：**

| ライブラリ | 採用理由 | 不採用理由 |
|----------|---------|----------|
| **Retrofit** | ✅ 業界標準、使いやすい、安定 | - |
| Ktor | マルチプラットフォーム対応 | 学習リソースが少ない、複雑 |
| OkHttp（単体） | 高速、低レベル制御 | 高レベルAPIがない、冗長 |
| Volley | Google製 | 古い、Coroutines非対応 |

---

### なぜCoilを選んだのか？

**Coil** を選択した理由：

1. **Kotlin First**
    - Kotlinで書かれた、Kotlinのための画像読み込みライブラリ
    - Coroutinesネイティブ対応
    - 軽量で高速

2. **Jetpack Compose対応**
    - `AsyncImage` Composableによる簡単な統合
    - Compose専用の最適化
    - 宣言的なAPI

3. **自動キャッシング**
    - メモリキャッシュとディスクキャッシュを自動管理
    - 効率的なリソース使用
    - 設定が簡単

4. **モダンな設計**
    - 最新のAndroid開発ベストプラクティスに準拠
    - 拡張しやすいAPI
    - 小さなAPKサイズ

**他の選択肢との比較：**

| ライブラリ | 採用理由 | 不採用理由 |
|----------|---------|----------|
| **Coil** | ✅ Kotlin First、Compose対応、軽量 | - |
| Glide | 成熟、高機能 | Java中心、Compose統合が複雑 |
| Picasso | シンプル | Compose非対応、開発停滞 |

---

### なぜRoom Databaseを選んだのか？

**Room** を選択した理由：

1. **公式推奨**
    - GoogleによるJetpackライブラリの一部
    - 公式ドキュメントが充実
    - Android開発のベストプラクティス

2. **SQLiteのラッパー**
    - SQLの強力さを保ちつつ、型安全性を提供
    - コンパイル時のクエリ検証
    - ボイラープレートコードの削減

3. **Flowサポート**
    - リアクティブなデータ監視
    - UIの自動更新
    - Coroutinesとの統合

4. **マイグレーション対応**
    - スキーマのバージョン管理
    - 安全なデータベース移行
    - テストツール

**他の選択肢との比較：**

| ライブラリ | 採用理由 | 不採用理由 |
|----------|---------|----------|
| **Room** | ✅ 公式推奨、型安全、Flow対応 | - |
| SQLite（直接） | 柔軟性が高い | ボイラープレート多い、エラーが多い |
| Realm | 高速、シンプル | 大きなライブラリサイズ、学習コスト |
| ObjectBox | 非常に高速 | ニッチ、ドキュメント不足 |

---

### なぜHiltを選んだのか？

**Hilt** を選択した理由：

1. **Android専用DI**
    - Android開発に特化した設計
    - Activityライフサイクル対応
    - ViewModelとの統合が簡単

2. **Daggerベース**
    - Daggerの強力さを保ちつつ、簡潔なAPI
    - コンパイル時の依存性解決
    - パフォーマンスが優れている

3. **Google推奨**
    - Jetpackライブラリとの統合
    - 公式ドキュメントが充実
    - 長期的なサポート

4. **定型コードの削減**
    - アノテーションベース
    - 自動的なコンポーネント生成
    - テストが簡単

**他の選択肢との比較：**

| ライブラリ | 採用理由 | 不採用理由 |
|----------|---------|----------|
| **Hilt** | ✅ Android専用、Daggerベース、簡潔 | - |
| Dagger | 強力、高速 | 複雑、学習コスト高い |
| Koin | Kotlinフレンドリー | ランタイム解決、エラー発見が遅い |
| 手動DI | シンプル | スケールしない、ボイラープレート |

---

### なぜGsonを選んだのか？

**Gson** を選択した理由：

1. **成熟したライブラリ**
    - Google製の信頼性
    - 長年の実績
    - 安定したパフォーマンス

2. **Retrofitとの統合**
    - デフォルトのコンバーター
    - 設定が簡単
    - トラブルシューティングが容易

3. **柔軟性**
    - カスタムシリアライザー/デシリアライザー
    - アノテーションによる制御
    - null安全

**他の選択肢との比較：**

| ライブラリ | 採用理由 | 不採用理由 |
|----------|---------|----------|
| **Gson** | ✅ 成熟、Retrofit統合、Google製 | - |
| Moshi | Kotlin最適化 | 若干複雑、学習リソース少ない |
| Kotlinx Serialization | Kotlin公式 | Retrofitとの統合が複雑 |
| Jackson | 高機能 | 重い、Android向けではない |

---

### なぜMVVMアーキテクチャを選んだのか？

**MVVM (Model-View-ViewModel)** を選択した理由：

1. **Google推奨**
    - Android Architecture Componentsの標準パターン
    - Jetpack ライブラリとの統合
    - 公式ガイドで推奨

2. **関心の分離**
    - UIロジックとビジネスロジックの分離
    - テストしやすい
    - 保守性が高い

3. **リアクティブ**
    - StateFlowによるUI自動更新
    - データバインディング
    - 宣言的UI（Compose）との相性が良い

4. **スケーラビリティ**
    - 大規模アプリでも管理しやすい
    - チーム開発に適している
    - 責任範囲が明確

**MVVMの構成要素：**
```
View (Compose)
    ↓ イベント
ViewModel (StateFlow)
    ↓ データ要求
Repository (キャッシュ判定)
    ↓ ネットワーク要求  ↓ ローカルデータ
API (Retrofit)      Database (Room)
```

---

### なぜClean Architectureを採用したのか？

**Clean Architecture** の層分離を採用した理由：

1. **保守性**
    - 各層の責任が明確
    - 変更の影響範囲が限定される
    - コードの理解が容易

2. **テスタビリティ**
    - 各層を独立してテスト可能
    - モックが簡単
    - ユニットテストが書きやすい

3. **再利用性**
    - ビジネスロジック（Domain層）の再利用
    - プラットフォーム非依存
    - 異なるUIでも同じロジックを使用可能

4. **拡張性**
    - 新機能追加が容易
    - 技術スタックの変更が簡単
    - データソースの追加が簡単

**層の責任：**

| 層 | 責任 | 依存方向 |
|---|------|---------|
| **Presentation** | UI、ユーザー操作 | → Domain |
| **Domain** | ビジネスロジック、モデル | 独立 |
| **Data** | データ取得、永続化 | → Domain |

---

### なぜキャッシュファースト戦略を採用したのか？

**キャッシュファースト戦略** を採用した理由：

1. **ユーザー体験の向上**
    - 即座にコンテンツを表示
    - ローディング時間の削減
    - オフライン対応

2. **ネットワーク負荷の軽減**
    - API呼び出し回数の削減
    - データ通信量の節約
    - レート制限の回避

3. **パフォーマンス**
    - ローカルデータベースは高速
    - バックグラウンド更新
    - スムーズなUI

4. **コスト削減**
    - APIコール数の削減
    - ユーザーのデータ通信量削減
    - サーバー負荷の軽減

**実装フロー：**
```
1. ユーザーがデータをリクエスト
   ↓
2. キャッシュをチェック
   ↓
3a. キャッシュが有効 → 即座に表示
   ↓
4a. バックグラウンドで更新（オプション）

3b. キャッシュが無効 → APIから取得
   ↓
4b. キャッシュに保存 → 表示
```

**キャッシュ有効期限：** 24時間

---

### なぜ指数バックオフリトライを実装したのか？

**指数バックオフ (Exponential Backoff)** を実装した理由：

1. **サーバー保護**
    - 一時的な障害時に過負荷を避ける
    - レート制限の回避
    - サーバーの回復時間を確保

2. **成功率の向上**
    - 一時的なネットワークエラーを自動回復
    - ユーザーの手動リトライ不要
    - 全体的な成功率が向上

3. **ベストプラクティス**
    - API設計のベストプラクティス
    - Google、AWSなどが推奨
    - 業界標準のアプローチ

4. **ユーザー体験**
    - 自動リトライで手間が減る
    - エラー画面の表示頻度が減る
    - スムーズな利用体験

**リトライ戦略：**
```
試行1: 即座
試行2: 1秒後
試行3: 2秒後
試行4: 4秒後（最大3回まで）
```

---

### 技術選定の原則

このプロジェクトでは、以下の原則に基づいて技術を選定しました：

1. **業界標準の採用**
    - 実務で広く使われている技術
    - 求人市場で求められるスキル
    - 長期的なサポートが期待できる

2. **Kotlinファースト**
    - Kotlinに最適化されたライブラリ
    - Coroutines/Flowネイティブ対応
    - モダンな言語機能の活用

3. **Jetpack優先**
    - Google公式ライブラリ
    - Android Architecture Componentsとの統合
    - 長期的なメンテナンス保証

4. **学習コストと実用性のバランス**
    - 学習リソースが豊富
    - トラブルシューティングが容易
    - 実務に直結するスキル

5. **パフォーマンスと保守性**
    - 高速で効率的
    - コードの可読性が高い
    - テストしやすい

---

これらの技術選定により、モダンで保守性が高く、実務に即したAndroidアプリを開発することができました。